#![doc = include_str!("../README.md")]
#![deny(missing_docs)]
#![cfg_attr(test, deny(warnings))]

use proc_macro::TokenStream;

/// Common helper code re-used across macros.
#[allow(dead_code)]
pub(crate) mod common {
    pub mod error;
    pub mod parse;
}

/// Implementation related to the Strut application’s entrypoint function.
mod entry;

/// Implementation related to the application configuration.
mod config {
    /// Implementation related to the configuration struct fields.
    pub mod field {
        /// Output generator.
        pub mod generator;
        /// Input representation.
        pub mod input;
    }

    /// Implementation related to the configuration enums.
    pub mod choice;
}

/// Marks an `async` main function as the main function of this Strut
/// application. This macro helps boot the Strut application without having to
/// use [`App`](../strut/struct.App.html) or
/// [`Launchpad`](../strut/struct.Launchpad.html) directly.
///
/// This macro is designed as familiar syntactic sugar for applications that
/// rely on the default Strut startup behavior. For more complex cases, where
/// customizing the startup wiring is required, use the
/// [`Launchpad`](../strut/struct.Launchpad.html) instead.
///
/// This macro can only be used on an `async fn main() { /* ... */ }` definition.
///
/// ## Example
///
/// ```
/// #[strut::main]
/// async fn main() {
///     println!("Hello, world!");
/// }
/// ```
///
/// The invocation above is equivalent to:
///
/// ```
/// fn main() {
///     strut::App::boot(async {
///         println!("Hello, world!");
///     });
/// }
/// ```
///
/// ## Negative examples
///
/// The following invocations do not compile.
///
/// The function must be called `main`:
///
/// ```compile_fail
/// #[strut::main]
/// async fn some_function() {}
/// ```
///
/// The function must have no arguments defined:
///
/// ```compile_fail
/// #[strut::main]
/// async fn main(input: bool) {}
/// ```
///
/// The function must be `async`:
///
/// ```compile_fail
/// #[strut::main]
/// fn main() {}
/// ```
///
/// The function must define no return type (not even a union type):
///
/// ```compile_fail
/// #[strut::main]
/// fn main() -> () {}
/// ```
#[proc_macro_attribute]
pub fn main(attr: TokenStream, item: TokenStream) -> TokenStream {
    entry::main(attr.into(), item.into())
        .unwrap_or_else(|error| error)
        .into()
}

/// Provides an in-house deriving of the `serde` crate’s `Deserialize` trait,
/// focusing on flexibly interpreting human-provided inputs.
///
/// The usage is best explained with the example below. The logic of comparing
/// the input string with all the aliases may be provided by referencing a
/// function with the signature `(a: &str, b: &str) -> bool`.
///
/// Every variant gets an implicit alias generated by taking the alias’s name
/// and converting it to `snake_case`.
///
/// ## Example
///
/// ```rust
/// use strut_factory::Deserialize as StrutDeserialize;
/// use serde_json::from_str;
///
/// #[derive(StrutDeserialize)]
/// #[strut(eq_fn = compare)]
/// enum SomeValue {
///     #[strut(alias = "alpha", alias = "first")]
///     AlphaFirst,
///     #[strut(alias = "other")]
///     BravoSecond,
///     CharlieThird,
/// }
///
/// /// The function used to compare the input string against all aliases.
/// fn compare(a: &str, b: &str) -> bool {
///     a.eq_ignore_ascii_case(b)
/// }
///
/// assert!(matches!(from_str("\"alpha_first\"").unwrap(), SomeValue::AlphaFirst));
/// assert!(matches!(from_str("\"alpha\"").unwrap(), SomeValue::AlphaFirst));
/// assert!(matches!(from_str("\"FIRST\"").unwrap(), SomeValue::AlphaFirst));
///
/// assert!(matches!(from_str("\"BRAVO_SECOND\"").unwrap(), SomeValue::BravoSecond));
/// assert!(matches!(from_str("\"Other\"").unwrap(), SomeValue::BravoSecond));
///
/// assert!(matches!(from_str("\"Charlie_Third\"").unwrap(), SomeValue::CharlieThird));
/// ```
#[proc_macro_derive(Deserialize, attributes(strut))]
pub fn config_choice(attr: TokenStream) -> TokenStream {
    // Parse input
    let input = syn::parse_macro_input!(attr as syn::DeriveInput);

    // Delegate
    config::choice::config_choice(input)
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}

/// The Strut ecosystem often forgoes deriving the
/// [`Deserialize`](serde::Deserialize) implementation, and instead implements
/// that trait manually in order to provide enhance flexibility and developer
/// convenience when deserializing things like application configuration. Manual
/// implementation of `Deserialize` involves a fair amount of boilerplate code,
/// while only a small portion of that boilerplate is really worth customizing.
///
/// The “usual” implementation of `Deserialize` (from a map-style input) goes
/// through the following beats:
///
/// 1. Define an `Option` for every field in the target struct/enum.
/// 2. Iterate over all key-value pairs in the input map.
/// 3. If a key is recognized, put its value into the corresponding `Option`.
/// 4. Instantiate the target struct/enum with the collected values, or fail.
///
/// This macro generates a helper enum that abstracts away most of the code that is
/// generally not worth customizing. This helper enum has the following features:
///
/// - Each variant represents a field on the target struct/enum.
/// - The helper enum itself also implements `Deserialize` from a string input.
///     - This implementation allows to recognize the string keys in the input
///         map.
///     - This deserialization uses the given **key matcher function** to match
///         input keys onto expected keys.
///     - The key matcher function may be as strict or as relaxed as necessary.
///     - The Strut ecosystem provides the
///         [`eq_as_slugs`](strut_deserialize::Slug::eq_as_slugs) function as
///         a suggested key matcher function for application config keys.
/// - Each variant may have any number of string aliases, making the input key
///     matching even more flexible.
/// - Variants have the `poll` function, which takes mutable references to the
///     input [`MapAccess`](serde::de::MapAccess) and to a target `Option`,
///     and populates that `Option` with whatever
///     [`next_value`](serde::de::MapAccess::next_value) returns.
///     - If the given `Option` reference is already `Some`, this function
///         generates an appropriate “duplicate value” error.
/// - Variants have the `take` function, which takes the target `Option`, and
///     returns its wrapped value.
///     - If the given `Option` is `None`, this function generates an appropriate
///         “required value missing” error.
///
/// Thanks to Rust’s robust type inference mechanisms, this helper enum can be
/// used cleanly (see below), almost like with dynamically typed languages.
///
/// ## Example
///
/// The usage of this macro is likely best described with an example:
///
/// ```
/// /// Here is a struct, for which we want to implement custom deserialization
/// struct SomeStruct {
///     field_a: i64,
///     field_b: String,
/// }
///
/// /// When matching keys from the input, we want to compare case-insensitively,
/// /// e.g., `FIELD_A` should match `field_a`. We need to define a matcher function
/// /// for that. The signature of this function must be `(a: &str, b: &str) -> bool`.
/// fn eq_fn(a: &str, b: &str) -> bool {
///     a.eq_ignore_ascii_case(b)
/// }
///
/// /// Implement the helper enum named `SomeStructField` to help write
/// /// deserialization logic for `SomeStruct`.
/// strut_factory::impl_deserialize_field!(
///     SomeStructField,
///     eq_fn,
///     field_a,
///     field_b | alias_b | another_b,
/// );
/// ```
///
/// Our goal is to take a map-like input (e.g., a JSON or YAML object) and produce
/// a new instance of `SomeStruct`.
///
/// We pass the name of the helper enum as the first argument to the macro.
///
/// We will use the `eq_fn` function to match keys in the input map to the
/// struct fields. We pass the path to this function as the second argument to
/// the macro.
///
/// The helper enum will have two variants:
///
/// First variant is named `field_a`, and it is matched from any string for
/// which `eq_fn` returns `true`, when compared against the string `"field_a"`.
///
/// Second variant is named `field_b`, with similar matching rules. However,
/// this variant will also be matched against the strings `"alias_b"` and
/// `"another_b"`.
///
/// The call-site above would expand to something like this:
///
/// ```rust,ignore
/// #[allow(non_camel_case_types)]
/// enum SomeStructField {
///     field_a,
///     field_b,
///     __ignore, // fall-back case for unrecognized input
/// }
///
/// impl SomeStructField {
///     // ... convenience methods
/// }
///
/// impl<'de> serde::de::Deserialize<'de> for SomeStructField {
///     // ... make helper enum deserializable
/// }
/// ```
///
/// The field names passed into the macro (e.g., `field_a`, `field_b`, etc.) will
/// be used verbatim in the error messages that guide the user to providing correct
/// data for deserialization. In this example, the field names match the struct
/// fields exactly, but this is not a requirement.
///
/// Here’s the expanded example, showing the intended usage:
///
/// ```
/// use std::fmt::Formatter;
/// use serde::{Deserialize, Deserializer};
/// use serde::de::{MapAccess, Visitor};
/// use strut_factory::impl_deserialize_field;
///
/// struct SomeStruct {
///     field_a: i64,
///     field_b: String,
/// }
///
/// fn eq_fn(a: &str, b: &str) -> bool {
///     a.eq_ignore_ascii_case(b)
/// }
///
/// impl_deserialize_field!(
///     SomeStructField,
///     eq_fn,
///     field_a,
///     field_b | alias_b | another_b,
/// );
///
/// /// Implement `Deserialize` via a custom `Visitor`
/// impl<'de> Deserialize<'de> for SomeStruct {
///     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
///     where
///         D: Deserializer<'de>,
///     {
///         deserializer.deserialize_map(SomeStructVisitor)
///     }
/// }
///
/// struct SomeStructVisitor;
///
/// impl<'de> Visitor<'de> for SomeStructVisitor {
///     type Value = SomeStruct;
///
///     fn expecting(&self, formatter: &mut Formatter) -> std::fmt::Result {
///         formatter.write_str("a map of SomeStruct")
///     }
///
///     fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
///     where
///         A: MapAccess<'de>,
///     {
///         // Define an `Option` for every deserialized field
///         let mut field_a = None; // Rust can infer type `Option<i64>` from code below
///         let mut field_b = None; // here inferred type is `Option<String>`
///
///         while let Some(key) = map.next_key()? { // How does Rust know what is the type of `key`? See next line.
///             match key { // We match against `SomeStructField` variants, so compiler infers that key is of type `SomeStructField`.
///                 SomeStructField::field_a => key.poll(&mut map, &mut field_a)?, // takes next map value, with readable error handling
///                 //                              ^^^^ convenience method
///                 SomeStructField::field_b => key.poll(&mut map, &mut field_b)?,
///                 SomeStructField::__ignore => map.next_value()?,
///             };
///         }
///
///         Ok(SomeStruct{
///             field_a: SomeStructField::field_a.take(field_a)?, // takes required value out of the `Option`, with readable error handling
///             //                                ^^^^ convenience method
///             field_b: field_b.unwrap_or_else(default_field_b), // alternative error-less approach, when a default exists
///         })
///     }
/// }
///
/// fn default_field_b() -> String {
///     "some_default".to_string()
/// }
/// ```
///
/// With the help of this macro, we mostly just need to implement the `visit_map`
/// method on a custom [`Visitor`](serde::de::Visitor). This happens to be exactly
/// the method where most deserialization customizations would happen. Even without
/// such customizations, the helper enum alone, with its flexible key matching and
/// key aliasing, provides significant improvement (in terms of usage convenience)
/// on the standard derived implementation of [`Deserialize`](serde::de::Deserialize).
#[proc_macro]
pub fn impl_deserialize_field(input: TokenStream) -> TokenStream {
    config::field::generator::impl_deserialize_field(input)
}
